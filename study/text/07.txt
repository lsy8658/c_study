표준함수 : C 언어 자체에서 제공하는 함수

- 함수의 원형 : 함수를 사용하는 데 필요한 사항을 
미리 선언하는 문장

- 필요한 표준함수의 원형이 선언되어 있는 헤더 파일을 
미리 포함 ( #include ) 해야 함

사용자 정의 함수 : 사용자의 필요에 따라 특정 기능을 
수행하도록 정의되는 함수

매개변수 )

실 매개변수 : 함수를 호출하는 문장에 쓰이는 매개변수
ex ) 함수(x, y)  x y 가 실 매개변수

형식 매개변수 : 
- 피 호풀 함수의 헤더에 선언되는 매개변수
- 함수의 지역변수처럼 사용할 수 있음
- int sum (int a , int b) { ... } a b 가 형식 매개변수

실 매개변수와 형식 매개변수는 자료형과 개수가 일치해야 함 :
- 자료형이 일치하지 않으면 묵시적 형 변환을 함
- 개수가 일치하지 않을 경우 에러 유발

-------------------------------------------------

int sum (int a, int b);  -> 함수 원형

함수 원형 : 매개변수의 개수와 자료형에 대한 정보만 알릴 수 있으면 
되므로 변수의 이름은 중료하지 않음

-------------------------------------------------

주소를 전달하기 위해 형식 매개변수를 '포인터' 형으로 선언함

-------------------------------------------------
( 포인터 )

int a = 10;
int *p = &a;  // &a : a의 주소

printf("%d\n", *p);  // *p : 포인터가 가리키는 값 → 10

주요 기호
기호	의미
&	변수의 주소를 얻음
*	주소가 가리키는 값에 접근

int a = 5;
int *p = &a;

*p = 20;  // 포인터로 a의 값 변경
printf("%d\n", a);  // 20

포인터 = “주소를 담는 변수”
& = 주소를 가져옴
* = 주소 안의 값에 접근
-------------------------------------------------

유효범위 (scope)란 ?
- 변수나 함수 등의 명칭을 사용할 수 있는 영역[지역변수, 전역변수]

기억 클래스 (storage class)란 ?
- 변수의 존속기간 (lifetime), 유효범위, 저장위치 등을
결정하는 개념
- 자동변수, 정적변수, 외부변수, 레지스터 변수

변수의 기억 클래스 종류 ~~
1. 자동 변수 (auto)
2. 정적 변수 (static)
3. 외부 변수 (extern)
4. 레지스터 변수(register)


변수의 저장 클래스(storage class) 개념 ]

1 ) 🔹 auto 🔹 - 기본 지역 변수 (기본값)

함수 안에서 선언되는 일반 변수는 자동으로 auto임.

즉, 자동 저장 기간(함수 끝나면 사라짐).

명시적으로 auto를 쓸 일은 거의 없음.

void func() {
    auto int x = 10;  // == 그냥 int x = 10; 과 같음
}

👉 특징:

스택에 저장됨

함수 종료 시 소멸

초기화 안 하면 쓰레기값


2 ) 🔹 static 🔹 — 정적 변수

프로그램 전체 실행 동안 메모리에 유지됨.

하지만 함수 안에서 선언되면 그 함수 내부에서만 접근 가능.

한 번만 초기화되고, 이후 값 유지됨.

void counter() {
    static int count = 0;  // 최초 한 번만 초기화
    count++;
    printf("%d\n", count);
}
→ 여러 번 호출해도 count가 계속 누적됨.

👉 특징:

프로그램 끝날 때까지 메모리에 유지

지역 변수처럼 스코프 제한 가능

전역 변수로 쓰면 다른 파일에서 접근 불가 (static 전역 변수는 파일 내부 전용)


 3 ) 🔹 extern 🔹 — 외부 변수 참조

다른 파일에 선언된 전역 변수를 사용하고 싶을 때 씀.

extern은 “이 변수는 다른 곳에 정의되어 있음”을 알려줌.

// file1.c
int count = 10;

// file2.c
extern int count;  // file1.c의 count를 참조
printf("%d", count);

👉 특징:

변수는 한 곳에서만 실제 정의 (int count = ...)

다른 파일에서는 extern으로 선언만 함


4 ) 🔹register🔹 — CPU 레지스터에 저장 요청

변수를 메모리(RAM) 대신 CPU 레지스터에 저장하자는 힌트야.

접근 속도가 빠름 ⚡ (이론상).

단, 컴파일러가 “꼭” 레지스터에 넣어준다는 보장은 없음.

void test() {
    register int i;
    for (i = 0; i < 1000; i++)
        printf("%d ", i);
}
👉 루프에서 자주 쓰이는 변수(i 등)는 빠른 접근을 위해 register로 선언할 수 있어.

제한 사항

register 변수는 메모리 주소가 없음 →
그래서 &i 같은 주소 연산자(&) 를 쓸 수 없어 ❌

register int x = 10;
printf("%p", &x);  // ❌ 오류!

👉 register 변수는 전역 변수로 선언할 수 없다. ❌

register의 의미는

“이 변수는 CPU 레지스터 안에 저장해서 빠르게 접근하고 싶다”
라는 지역적 요청이야.

그런데 전역 변수(global variable) 는

프로그램 전체가 공유하는 메모리 공간(데이터 영역)에 있어야 해.

레지스터는

함수 실행 중 잠깐 쓰이고

스코프(유효 범위)가 함수 안으로 제한돼

→ 그래서 전역 변수는 레지스터에 둘 수가 없어.

올바른 사용 위치

register는 함수 내부(local scope) 에서만 가능함 👇

void func() {
    register int i;  // ✅ OK
    for (i = 0; i < 10; i++)
        printf("%d ", i);
}
-------------------------------------------------

💡 한 줄 요약
auto: 기본 지역 변수 /함수 안 기본 변수
static: 값 유지
extern: 외부 변수 / 다른 파일 변수 가져옴
register: 빠른 접근용 (주소 불가)
-------------------------------------------------
auto

“변수의 값이 자동적으로 0으로 초기화되게 한다.” ❌

❌ 잘못된 설명.

auto 변수(기본 지역 변수)는 자동 초기화 안 됨 → 쓰레기값 들어감.

0으로 자동 초기화되는 건 static / extern 변수야.

2️⃣ static

“변수가 프로그램을 시작할 때 생성되어 프로그램을 마칠 때까지 유지된다.” ✅

✅ 정답!

static 변수는 프로그램 시작 시 생성 → 종료 시 소멸

지역에 선언돼도 값이 함수 호출 간 유지됨

3️⃣ extern

“선언된 블록에 들어갈 때 생성되어 나갈 때 소멸된다.” ❌

❌ extern은 외부 전역 변수 참조용이지, 블록 안에서 생성·소멸되지 않음.

오히려 이미 존재하는 전역 변수를 “참조”할 뿐.

4️⃣ register

“CPU의 레지스터에 할당되는 것이 보장된다.” ❌

❌ 보장되지 않음.

단지 “레지스터에 넣어달라”는 컴파일러에 대한 요청일 뿐.

컴파일러가 무시할 수도 있음.

-------------------------------------------------

-------------------------------------------------